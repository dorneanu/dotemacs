* [[https://rossabaker.com/configs/emacs/][Ross A. Baker: Emacs config]] :website:

[Y-09-04 Mon 10:%]

** Article

*** Emacs config

**** Introduction [[#introduction][#]]

***** The flavor of the day is vanilla [[#the-flavor-of-the-day-is-vanilla][#]]

This is a “vanilla” configuration, or an “Emacs from scratch,” built on a prerelease of Emacs 29 from Git.

Some users use a community configuration such as [[https://www.spacemacs.org/][Spacemacs]] or [[https://github.com/doomemacs/doomemacs][Doom]]. A more moderate approach is a starter kit like like [[https://github.com/bbatsov/prelude][Prelude]] or [[https://github.com/SystemCrafters/crafted-emacs][Crafted Emacs]], which hew closer to vanilla Emacs but give users a sensible head start. These are recommended paths for new users, and remain reasonable even after decades of experience.

I choose to start from the wretched defaults.

- It helps me better understand how it works.
- I am less likely to be surprised on upgrades.
- It's relaxing. Editor bonsai, if you will.

***** Guiding principles [[#guiding-principles][#]]

The default is to try built-in packages first, but be unafraid to augment with [[https://elpa.gnu.org/][ELPA]], [[https://melpa.org/][MELPA]], or even Git. These extra moving parts are managed by rigorously pinning all dependencies with Nix.

***** On licensing [[#on-licensing][#]]

Most of my configurations are permissively licensed, for both your convenience and their triviality. Emacs is challenging:

- Most configurations are markup and duct tape. Emacs configurations are written in a whole-ass language.

- Emacs Lisp has a stronger copyleft culture than most languages. Many of the =use-package= blocks that follow are copied straight out of of GPL-licensed documentation. The entire Emacs core, many third-party libraries, and several of its inspirational configurations are under the GPL, beckoning us to quote them in all their virality.

So let's just publish under the GPL and call it a day, right?

This is a literate configuration. Prose and code. Creative Commons licenses are great for prose, but [[https://creativecommons.org/faq/#can-i-apply-a-creative-commons-license-to-software][not for code]]. =CC-BY-SA-4.0= is [[https://creativecommons.org/faq/#can-i-apply-a-creative-commons-license-to-software][one-way compatible]] with the =GPL-3.0=. We can license this entire work under the =CC-BY-SA-4.0=. Unified license, dual purpose.

That's swell, until we redistribute code licensed to us under the GPL. The compatibility is only one way. We can't republish that code under =CC-BY-SA-4.0=. Either the prose gets subsumed into the GPL, or else there's no license to unify the entire document.

Some =use-package= statements that follow are little more than “installation” recipes taken from the documentation of GPL projects. I assert that these falls under [[https://www.gnu.org/licenses/gpl-faq.en.html#GPLFairUse][“fair use” of GPL-covered programs]]. Any configuration that triggers the GPL will be published in a separate repository and stitched in here like any other GPL library.

With that effort, the license of this configuration as a whole is =CC-BY-SA-4.0=. I encourage you to try the same with your own literate configs.

CC0-1.0

#+begin_src chroma :tabindex 0
    ;; SPDX-License-Identifier: CC-BY-SA-4.0
#+end_src

Trivial stanzas are tagged into the public domain ( =CC0-1.0=).

**** Early tasks [[#early-tasks][#]]

An Emacs configuration can mostly be declared in any order, particularly with intelligent use of =use-package='s =:after= keyword. But there are a few things that benefit from going first.

***** Startup time [[#startup-time][#]]

I don't go to [[https://github.com/doomemacs/doomemacs/blob/35865ef5e89442e3809b8095199977053dd4210f/docs/faq.org#how-does-doom-start-up-so-quickly][Doom's extreme lengths]] to optimize startup time, but there are usually a few heavy hitters, and [[https://github.com/dholm/benchmark-init-el][benchmark-init-el]] helps find them. And with my Nix setup, I'm restarting Emacs a lot whenever I'm trying new packages, so it's worth a modest effort.

****** Benchmark [[#benchmark][#]]

[[https://github.com/dholm/benchmark-init-el][benchmark-init]] is a simple package that may or may not carry its weight versus =usepackage-compute-statistics=. Run =benchmark-init/show-durations-tabulated= to check this one out.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  benchmark-init
     :ensure  t
     :demand  t
     :hook  ( after-init  .  benchmark-init/deactivate )
     :config
     ( benchmark-init/activate ))
#+end_src

****** Garbage collection [[#garbage-collection][#]]

Increasing the garbage collector threshold is reputed to help at init. After startup, we revert on the [[https://gitlab.com/koral/gcmh][Garbage Collector Magic Hack]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  gcmh
     :ensure  t
     :diminish
     :init  ( setq  gc-cons-threshold  ( *  80  1024  1024 ))
     :hook  ( emacs-startup  .  gcmh-mode ))
#+end_src

****** Doom-like hooks [[#doom-like-hooks][#]]

We're also going to use [[https://gitlab.com/ajgrf/on.el][on.el]] to provide some of the same hooks Doom uses.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  on
     :ensure )
#+end_src

****** Security [[#security][#]]

For the love of all that is holy, do not continue with untrusted connections!

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  gnutls
     :defer  t
     :custom
     ( gnutls-verify-error  t ))
#+end_src

****** No littering [[#no-littering][#]]

Many packages leave crumbs in =user-emacs-directory= or even =$HOME=. Finding and configuring them individually is a hassle, so we rely on the community configuration of [[https://github.com/emacscollective/no-littering][=no-littering=]]. Run this early, because many of the crumb droppers are configured below!

The default is to put everything under =user-emacs-directory=, which for me is under =~/.config=. If I considered any of this data to be config, they'd be in this file! I keep mine in =~/.cache=.

Cleaning up the [[https://github.com/emacscollective/no-littering#native-compilation-cache][native compilation cache]] is “preferably” supposed to happen in =early-init.el=, but I'm trying to keep that as light as possible so as much as possible works without Home Manager. This seems early enough to avoid crapping in =~/.config/emacs=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  no-littering
     :ensure  t
     :init
     ( setq  no-littering-etc-directory  "~/.cache/emacs/etc/"
           no-littering-var-directory  "~/.cache/emacs/var/" )
     ( when  ( fboundp  'startup-redirect-eln-cache )
       ( startup-redirect-eln-cache
        ( convert-standard-filename
         ( expand-file-name   "eln-cache/"  no-littering-var-directory )))))
#+end_src

***** use-package keywords [[#use-package-keywords][#]]

****** bind-key [[#bind-key][#]]

[[https://github.com/jwiegley/use-package][use-package]] is built-in as of Emacs 29, but since we use =:bind=, we need to load =bind-key=. If we forget, we get the error: =Symbol's value as variable is void: personal-keybindings=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  bind-key
     :demand  t
     :bind
     ( :prefix-map  rab/files-map
      :prefix  "C-c f" )
     :bind
     ( :prefix-map  rab/toggles-map
      :prefix  "C-c t" )
     :config
     ( defun  rab/unbind-all  ( fn )
       "Unbinds a function everywhere."
       ( dolist  ( key  ( where-is-internal  fn  nil ))
         ( unbind-key  key ))))
#+end_src

****** Diminish [[#diminish][#]]

We also want to “diminish” most minor-mode indicators on the mode line. They're only interesting if they're in an unexpected state.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  diminish  :ensure  t )
#+end_src

***** Path setup [[#path-setup][#]]

Launching Emacs from the MacOS dock does not source my shell config, which leads to my Nix profile not being on the =$PATH=, which leads to errors, or worse, trying to install the execrable Xcode.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  exec-path-from-shell
     :ensure  t
     :demand  t
     :if  ( memq  window-system  ' ( mac  ns  x ))
     :config
     ( exec-path-from-shell-initialize ))
#+end_src

**** General customization [[#general-customization][#]]

I spun my wheels for a while over how to arrange my customizations, ignoring that Emacs has already done most of that work! I don't use Emacs' customize interface, preferring this version-controlled, literate config. However, its tree of =defgroups= is pretty reasonable, and more importantly, stops me from agonizing over them. This structure is modeled after that.

***** Editing [[#editing][#]]

****** Editing basics [[#editing-basics][#]]

******* Character radix [[#character-radix][#]]

Make =C-q= read a hex sequence instead of the default octal. Obscure, but I know more characters by their hex codes. This is also consistent with =C-x 8 =, which is more chars, but offers minibuffer completion.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  read-quoted-char-radix  16 )
#+end_src

******* Mark ring [[#mark-ring][#]]

The mark ring is the trail of breadcrumbs we leave with various commands. Vernon Grant gives a [[https://vernon-grant.com/discovering-emacs/efficiency-with-the-mark-ring/][good tutorial]] in his Discovering Emacs series.

=set-mark-command-repeat-pop= means we only need to hit =C-u= or =C-x= once before subsequent =C-SPC=, which makes it much nicer to navigate.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  set-mark-command-repeat-pop  t )
#+end_src

****** Indent [[#indent][#]]

Tabs are the devil's whitespace.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  simple
     :config
     ( setq-default  indent-tabs-mode  nil ))
#+end_src

****** Killing [[#killing][#]]

Put the clipboard on the kill ring before killing something else. Emacs isn't as violent as it sometimes sounds, I swear.

We also don't want to clutter the ring with consecutively duplicate values.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  simple
     :custom
     ( save-interprogram-paste-before-kill  t )
     ( kill-do-not-save-duplicates  t ))
#+end_src

****** Matching [[#matching][#]]

******* Bookmark [[#bookmark][#]]

Persist bookmarks each time we set one, not when Emacs exits.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  bookmark
     :custom
     ( bookmark-save-flag  1 ))
#+end_src

****** selected.el [[#selected-dot-el][#]]

[[https://github.com/Kungsgeten/selected.el][=selected.el=]] activates a keymap when there is an active region. I'm using it to replace the more traditional =delete-selection-mode=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  selected
     :ensure  t
     :diminish
     :config  ( selected-global-mode )
     :bind  ( :map  selected-keymap
            ( "q"  .  selected-off )
            ( "u"  .  upcase-region )
            ( "d"  .  downcase-region )
            ( "w"  .  count-words-region )
            ( "m"  .  apply-macro-to-region-lines )))
#+end_src

***** Convenience [[#convenience][#]]

****** Completion [[#completion][#]]

******* Copilot [[#copilot][#]]

This package is currently disabled due to absence of a license. See [[https://github.com/zerolfx/copilot.el/issues/80][issue #80]] for a discussion of what it would take.

I think Copilot's training was unethical, and I'm skeptical of its utility, but I need to get some experience with it.

=always= in =copilot-disable-predicates= turns off automatic completion. We can still reach it from =M-`=, which is chosen to be close to =M-TAB= and bound to a menubar command I don't ever use.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  copilot
     :disabled  t
     :ensure  t
     :custom
     ( copilot-disable-predicates  ' ( always ))
     :hook
     ( prog-mode  .  copilot-mode )
     :bind
     ( "M-`"  .  copilot-complete )
     :bind
     ( :map  rab/toggles-map
      ( "`"  .  copilot-mode ))
     :bind
     ( :map  copilot-completion-map
      ( "C-g"  .   'copilot-clear-overlay )
      ( "M-p"  .  'copilot-previous-completion )
      ( "M-n"  .  'copilot-next-completion )
      ( ""  .  'copilot-accept-completion )
      ( "M-f"  .  'copilot-accept-completion-by-word )
      ( "M-"  .  'copilot-accept-completion-by-line )))
#+end_src

It's not in MELPA, but it's a trivial build:

MIT

#+begin_src chroma :tabindex 0
    let
     copilot-lisp  =  epkgs . trivialBuild  {
       pname  =  "copilot-lisp" ;
       src  =  inputs . copilot-el ;
       packageRequires  =  [
         epkgs . dash
         epkgs . editorconfig
         epkgs . s
       ];
     };
     copilot-dist  =  pkgs . stdenv . mkDerivation  {
       name  =  "copilot-dist" ;
       src  =  inputs . copilot-el ;
       installPhase  =  ''
         LISPDIR=$out/share/emacs/site-lisp
         mkdir -p $LISPDIR
         cp -R dist $LISPDIR
       '' ;
     };
   in
   pkgs . symlinkJoin  {
     name  =  "copilot.el" ;
     paths  =  [  copilot-lisp  copilot-dist  ];
   }
#+end_src

It also depends on Node.

MIT

#+begin_src chroma :tabindex 0
    ({  pkgs ,  ... }:  {
     home . packages  =  [  pkgs . nodejs  ];
   })
#+end_src

****** Corfu [[#corfu][#]]

We use [[https://github.com/minad/corfu][Corfu]] for small, in-buffer popups of completion candidates. Autocompletion of method names in code is a classic use case.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  corfu
     :ensure  t
     :hook  ( on-first-buffer  .  global-corfu-mode ))
#+end_src

****** Docker [[#docker][#]]

[[https://github.com/Silex/docker.el][=docker.el=]] “manages Docker from Emacs.” Note that while a [[https://podman.io/][Podman daemon]] works great, the Podman client [[https://github.com/Silex/docker.el/issues/110][is incompatible]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  docker
     :ensure  t
     :defer  t )
#+end_src

****** Exiting [[#exiting][#]]

I'd usually rather exit Slack, to be quite honest.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  confirm-kill-emacs  'yes-or-no-p )
#+end_src

****** Display line numbers [[#display-line-numbers][#]]

=display-line-numbers= is a more performant replacement for the venerable old =linum=. We turn it on for program and configuration modes.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  display-line-numbers
     :custom
     ( display-line-numbers-widen  t )
     :hook
     (( prog-mode  conf-mode )  .  display-line-numbers-mode ))
#+end_src

****** Highlight line [[#highlight-line][#]]

Highlight the current line, only in the current buffer.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  hl-line
     :hook  ( on-first-buffer  .  global-hl-line-mode ))
#+end_src

****** ffap [[#ffap][#]]

=ffap=, short for “find file at point,” guesses a default file from the point. =ffap-bindings= rebinds several commands with ffap equivalents.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  ffap
     :hook  ( on-first-input  .  ffap-bindings ))
#+end_src

ffap invokes =gcc= and =g++=, which is fine, except on a Mac without Xcode. That brings up a dreaded dialog box.

MIT

#+begin_src chroma :tabindex 0
    ({  pkgs ,  ... }:  {  home . packages  =  [  pkgs . gcc  ];  })
#+end_src

****** Persist state [[#persist-state][#]]

[[https://codeberg.org/bram85/emacs-persist-state.git][Persist State]] flushes state that is normally flushed in =kill-emacs-hook=, which I'm trying not to call until I die.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  persist-state
     :ensure  t
     :hook
     ( on-first-input  .  persist-state-mode ))
#+end_src

****** Suggest [[#suggest][#]]

I keep lamenting the lack of a [[https://hoogle.haskell.org/][Hoogle]] for Emacs Lisp. [[https://github.com/Wilfred/suggest.el/][suggest.el]] is an interesting alternative: instead of types, it finds functions from example inputs and outputs.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  suggest
     :ensure  t )
#+end_src

****** Whitespace butler [[#whitespace-butler][#]]

I like builtin packages, but I like minimal diffs more. [[https://github.com/lewang/ws-butler][ws-butler]] is “unobtrusive”, which wins the day for me.

#+begin_quote
- Only lines touched get trimmed. If the white space at end of buffer is changed, then blank lines at the end of buffer are truncated respecting =require-final-newline=.
- Trimming only happens when saving.

#+end_quote

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  ws-butler
     :ensure  t
     :hook  ( on-first-buffer  .  ws-butler-global-mode )
     :diminish )
#+end_src

***** Files [[#files][#]]

****** Lock files [[#lock-files][#]]

On single-user environments, as we tend to run Emacs these days, those =.#*= files are more likely to confuse some other program as they are to protect us from conflicting edits.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  create-lockfiles  nil )
#+end_src

****** Auto-revert [[#auto-revert][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  autorevert
     :diminish  auto-revert-mode
     :hook  ( on-first-buffer  .  global-auto-revert-mode )
     :custom
     ( global-auto-revert-non-file-buffers  t ))
#+end_src

****** Recent files [[#recent-files][#]]

This maintains a list of recent files, as we often find in other applications. I wonder if it can or should be integrated with MacOS' list of recent files?

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  recentf
     :hook  ( on-first-file-hook  .  recentf-mode )
     :bind
     ( :map  rab/files-map
      ( "r"  .  recentf-open )))
#+end_src

***** Text [[#text][#]]

****** Case [[#case][#]]

******* DWIM case [[#dwim-case][#]]

These do-what-I-mean bindings are newer than the classic keybindings, but a better default.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  emacs
     :bind
     ([ remap  capitalize-word ]  .  capitalize-dwim )
     ([ remap  downcase-word ]  .  downcase-dwim )
     ([ remap  upcase-word ]  .  upcase-dwim ))
#+end_src

******* Title case [[#title-case][#]]

Gosh, I wish I'd had this when I was so active on [[https://musicbrainz.org/][MusicBrainz]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  titlecase
     :ensure  t
     :defer  t )
#+end_src

****** Jinx [[#jinx][#]]

[[https://github.com/minad/jinx][Jinx]] is a just-in-time spell checker.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  jinx
     :ensure  t
     :hook  ( on-first-buffer  .  global-jinx-mode )
     :bind
     ([ remap  ispell-word ]  .  jinx-correct )
     :bind
     ( :map  rab/toggles-map
      ( "$"  .  jinx-mode )))
#+end_src

This one requires a Nix build, [[https://github.com/GTrunSec/hive/blob/ce7c0087a055fb3f91a402ec0d2caeb4a3579d5f/nix/emacs/homeModules/packages.nix#L16][inspired by hive-std]]:

MIT

#+begin_src chroma :tabindex 0
    let
     jinx-lisp  =  epkgs . trivialBuild  {
       pname  =  "jinx-lisp" ;
       src  =  inputs . jinx ;
       packageRequires  =  [  epkgs . compat  ];
     };
     jinx-mod  =  pkgs . stdenv . mkDerivation  {
       name  =  "jinx-mod" ;
       src  =  inputs . jinx ;
       buildInputs  =  [  pkgs . enchant2  ];
       buildPhase  =  ''
         cc -I. -O2 -Wall -Wextra -fPIC -shared -o jinx-mod.dylib jinx-mod.c \
         -I ${ pkgs . enchant2 . dev } /include/enchant-2 -lenchant-2
       '' ;
       installPhase  =  ''
         LISPDIR=$out/share/emacs/site-lisp
         install -d $LISPDIR
         install *.dylib $LISPDIR
       '' ;
     };
   in
     pkgs . symlinkJoin  {
       name  =  "jinx" ;
       paths  =  [  jinx-lisp  jinx-mod  ];
     }
#+end_src

Let's not forget a dictionary.

MIT

#+begin_src chroma :tabindex 0
    ({  pkgs ,  ... }:  {
     home . packages  =  [
       pkgs . nuspell
       pkgs . hunspellDicts . en_US
     ];
   })
#+end_src

****** Markdown [[#markdown][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  markdown-mode
     :ensure  t )
#+end_src

****** Outlines [[#outlines][#]]

******* Org [[#org][#]]

Org Mode's timestamps are sadly not aware of time zones, but we can crudely approximate support by [[https://emacs.stackexchange.com/a/60590][setting =org-time-stamp-formats=]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  org
     :custom
     ( org-time-stamp-formats  ' ( "%Y-%m-%d %a"  .  "%Y-%m-%d %a %H:%M %Z" )))
#+end_src

******** ox-hugo [[#ox-hugo][#]]

We use [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]] for publishing.

=rab/ox-hugo-update-lastmod= can be used to update the timestamp of the exported tree at the current point.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  ox-hugo
     :ensure  t
     :after  org
     :config
     ( defun  rab/ox-hugo-update-lastmod  ()
       "Updates the EXPORT_HUGO_LAST_MOD property of the nearest element
   with EXPORT_FILE_NAME."
       ( interactive )
         ( save-excursion
           ( when-let*  (( elem  ( car  ( org-hugo--get-elem-with-prop  :EXPORT_FILE_NAME )))
                       ( begin  ( org-element-property  :begin  elem ))
                       ( time  ( format-time-string  ( org-time-stamp-format  t  t )  ( current-time ))))
             ( org-entry-put  begin  "EXPORT_HUGO_LASTMOD"  time )))))
#+end_src

We lightly customize ox-hugo by adding support for a =:code-license= header. This idea comes from [[https://sachachua.com/blog/2023/01/adding-a-custom-header-argument-to-org-mode-source-blocks-and-using-that-argument-during-export/][Sacha Chua]]. First, we need to add it to =org-babel-exp-code-template=:

This part is grody. We'd like to define a [[https://orgmode.org/worg/dev/org-export-reference.html][derived backend]], but ox-hugo's export commands are fairly intricate with the subtree support, and don't offer an obvious way to inject a new backend. Unfortunately, we resort to mutating the ox-hugo code. This is fine, as long as we don't have other ox-hugo sites.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( defun  rab/org-get-filled-template-argument  ( key  alist )
     "Looks up KEY in ALIST, which is assumed to be from a template
   filled by  `org-fill-template' .

     If the result is \"%key\", we assume the value was not present
    and return nil."
     ( let*  (( val  ( alist-get  key  alist ))
            ( fallthrough  ( concat  "%"  ( s-chop-left  1  ( symbol-name  key )))))
       ( unless  ( string=  fallthrough  val )  val )))

   ( defun  rab/org-hugo-src-block  ( src-block  _contents  info )
     "Invokes  `org-hugo-src-block'  on its arguments, and then wraps the
   result in a license div if `:code-license' is found in the block
   arguments of SRC-BLOCK."
     ( if-let*  (( result  ( org-hugo-src-block  src-block  _contents  info ))
               ( block-info
                ( org-with-point-at  ( org-element-property  :begin  src-block )
                  ( org-babel-get-src-block-info )))
               ( block-arguments  ( elt  block-info  2 ))
               ( license  ( rab/org-get-filled-template-argument
                         :code-license  block-arguments )))
         ( format  "%s\n\n%s\n\n"
                 license  result )
       result ))

   ( with-eval-after-load  'ox-hugo
     ( map-put!
      ( org-export-backend-transcoders  ( org-export-get-backend  'hugo ))
      'src-block  'rab/org-hugo-src-block ))
#+end_src

Code Snippet 1: [[https://sachachua.com/dotemacs/index.html#org7814eb7][Original]] by Sacha Chua

******** ox-slack [[#ox-slack][#]]

Mostly useful for =org-slack-export-to-clipboard-as-slack=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  ox-slack
     :ensure  t
     :after  org
     :bind
     ( :map  org-mode-map
      :prefix-map  rab/org-mode-map
      :prefix  "C-c m"
      ( "w"  .  org-slack-export-to-clipboard-as-slack )))
#+end_src

Apply [[https://github.com/titaniumbones/ox-slack/pull/9][this patch]] to fix the syntax for links. In Slack, turn on “Format messages with markup” in Advanced settings for link support.

MIT

#+begin_src chroma :tabindex 0
    epkgs . ox-slack . overrideAttrs ( old :  {
     patches  =  [  ../../src/emacs/ox-slack/github-9.patch  ];
   })
#+end_src

****** Subword mode [[#subword-mode][#]]

Subword mode helps us move around camel-case languages, and is mostly configured as a hook in those major modes. The only thing we customize about it is not wanting it cluttering the mode line.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  subword
     :defer  t
     :diminish )
#+end_src

****** Counting words [[#counting-words][#]]

The default binding of =M-== is =count-words-region=. The newer =count-words= counts the buffer when there's no active region.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( bind-key  [ remap  count-words-region ]  'count-words )
#+end_src

***** Data [[#data][#]]

****** Save place [[#save-place][#]]

This mode saves our place for when we revisit a file.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  saveplace
     :hook  ( on-first-buffer  .  save-place-mode ))
#+end_src

***** External [[#external][#]]

****** Processes [[#processes][#]]

****** RFC mode [[#rfc-mode][#]]

As an http4s author, I refer to RFCs constantly.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  rfc-mode
     :ensure  t
     :defer  t )
#+end_src

******* Envrc [[#envrc][#]]

I maintain a minimal home environment and push as much as I can to Nix flakes. This insulates me from conflicting dependencies, makes my projects more portable, and helps me share with Nix-enabled teammates.

Where possible, I add an =.envrc= file to load the environment from the flake.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  envrc
     :ensure  t
     :hook  ( on-first-file  .  envrc-global-mode ))
#+end_src

***** Programming [[#programming][#]]

****** Languages [[#languages][#]]

******* C# [[#c][#]]

I am not a C# developer, but I've been known to interview them.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  csharp-mode
     :mode  (( rx  ".cs"  eos )  .  'csharp-ts-mode )
     :hook  ( csharp-ts-mode  .  subword-mode ))
#+end_src

******* Lisp [[#lisp][#]]

I would like my property lists to align not like this

CC0-1.0

#+begin_src chroma :tabindex 0
    ( :prefix-map  rab/git-map
                :prefix  "C-c g" )
#+end_src

but like this:

CC0-1.0

#+begin_src chroma :tabindex 0
    ( :prefix-map  rab/git-map
    :prefix  "C-c g" )
#+end_src

The answer is almost verbatim from Stack Overflow, but put in a =use-package= and changed to my namespace. I also applied the “bonus,” because my primary itch is =use-package= bindings.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  lisp-mode
     :defer
     :config
     ( defun  rab/calculate-lisp-indent  ( &optional  parse-start )
       "Add better indentation for quoted and backquoted lists."
       ;; This line because `calculate-lisp-indent-last-sexp` was defined with `defvar`
       ;; with it's value ommited, marking it special and only defining it locally. So
       ;; if you don't have this, you'll get a void variable error.
       ( defvar  calculate-lisp-indent-last-sexp )
       ( save-excursion
         ( beginning-of-line )
         ( let  (( indent-point  ( point ))
               state
               ;; setting this to a number inhibits calling hook
               ( desired-indent  nil )
               ( retry  t )
               calculate-lisp-indent-last-sexp  containing-sexp )
           ( cond  (( or  ( markerp  parse-start )  ( integerp  parse-start ))
                  ( goto-char  parse-start ))
                 (( null  parse-start )  ( beginning-of-defun ))
                 ( t  ( setq  state  parse-start )))
           ( unless  state
             ;; Find outermost containing sexp
             ( while  ( <  ( point )  indent-point )
               ( setq  state  ( parse-partial-sexp  ( point )  indent-point  0 ))))
           ;; Find innermost containing sexp
           ( while  ( and  retry
                       state
                       ( >  ( elt  state  0 )  0 ))
             ( setq  retry  nil )
             ( setq  calculate-lisp-indent-last-sexp  ( elt  state  2 ))
             ( setq  containing-sexp  ( elt  state  1 ))
             ;; Position following last unclosed open.
             ( goto-char  ( 1+  containing-sexp ))
             ;; Is there a complete sexp since then?
             ( if  ( and  calculate-lisp-indent-last-sexp
                      ( >  calculate-lisp-indent-last-sexp  ( point )))
                 ;; Yes, but is there a containing sexp after that?
                 ( let  (( peek  ( parse-partial-sexp  calculate-lisp-indent-last-sexp
                                                 indent-point  0 )))
                   ( if  ( setq  retry  ( car  ( cdr  peek )))  ( setq  state  peek )))))
           ( if  retry
               nil
             ;; Innermost containing sexp found
             ( goto-char  ( 1+  containing-sexp ))
             ( if  ( not  calculate-lisp-indent-last-sexp )
                 ;; indent-point immediately follows open paren.
                 ;; Don't call hook.
                 ( setq  desired-indent  ( current-column ))
               ;; Find the start of first element of containing sexp.
               ( parse-partial-sexp  ( point )  calculate-lisp-indent-last-sexp  0  t )
               ( cond  (( looking-at  "\\s(" )
                      ;; First element of containing sexp is a list.
                      ;; Indent under that list.
                      )
                     (( >  ( save-excursion  ( forward-line  1 )  ( point ))
                         calculate-lisp-indent-last-sexp )
                      ;; This is the first line to start within the containing sexp.
                      ;; It's almost certainly a function call.
                      ( if  ( or
                           ;; Containing sexp has nothing before this line
                           ;; except the first element. Indent under that element.
                           ( =  ( point )  calculate-lisp-indent-last-sexp )

                           ;; First sexp after `containing-sexp' is a keyword. This
                           ;; condition is more debatable. It's so that I can have
                           ;; unquoted plists in macros. It assumes that you won't
                           ;; make a function whose name is a keyword.
                           ( when-let  ( char-after  ( char-after  ( 1+  containing-sexp )))
                             ( char-equal  char-after  ?: ))

                           ;; Check for quotes or backquotes around.
                           ( let*  (( positions  ( elt  state  9 ))
                                  ( last  ( car  ( last  positions )))
                                  ( rest  ( reverse  ( butlast  positions )))
                                  ( any-quoted-p  nil )
                                  ( point  nil ))
                             ( or
                              ( when-let  ( char  ( char-before  last ))
                                ( or  ( char-equal  char  ?' )
                                    ( char-equal  char  ?` )))
                              ( progn
                                ( while  ( and  rest  ( not  any-quoted-p ))
                                  ( setq  point  ( pop  rest ))
                                  ( setq  any-quoted-p
                                        ( or
                                         ( when-let  ( char  ( char-before  point ))
                                           ( or  ( char-equal  char  ?' )
                                               ( char-equal  char  ?` )))
                                         ( save-excursion
                                           ( goto-char  ( 1+  point ))
                                           ( looking-at-p
                                            "\\(?:back\\)?quote[\t\n\f\s]+(" )))))
                                any-quoted-p ))))
                          ;; Containing sexp has nothing before this line
                          ;; except the first element.  Indent under that element.
                          nil
                        ;; Skip the first element, find start of second (the first
                        ;; argument of the function call) and indent under.
                        ( progn  ( forward-sexp  1 )
                               ( parse-partial-sexp  ( point )
                                                   calculate-lisp-indent-last-sexp
                                                   0  t )))
                      ( backward-prefix-chars ))
                     ( t
                      ;; Indent beneath first sexp on same line as
                      ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                      ;; almost certainly a function call.
                      ( goto-char  calculate-lisp-indent-last-sexp )
                      ( beginning-of-line )
                      ( parse-partial-sexp  ( point )  calculate-lisp-indent-last-sexp
                                          0  t )
                      ( backward-prefix-chars )))))
           ;; Point is at the point to indent under unless we are inside a string.
           ;; Call indentation hook except when overridden by lisp-indent-offset
           ;; or if the desired indentation has already been computed.
           ( let  (( normal-indent  ( current-column )))
             ( cond  (( elt  state  3 )
                    ;; Inside a string, don't change indentation.
                    nil )
                   (( and  ( integerp  lisp-indent-offset )  containing-sexp )
                    ;; Indent by constant offset
                    ( goto-char  containing-sexp )
                    ( +  ( current-column )  lisp-indent-offset ))
                   ;; in this case calculate-lisp-indent-last-sexp is not nil
                   ( calculate-lisp-indent-last-sexp
                    ( or
                     ;; try to align the parameters of a known function
                     ( and  lisp-indent-function
                          ( not  retry )
                          ( funcall  lisp-indent-function  indent-point  state ))
                     ;; If the function has no special alignment
                     ;; or it does not apply to this argument,
                     ;; try to align a constant-symbol under the last
                     ;; preceding constant symbol, if there is such one of
                     ;; the last 2 preceding symbols, in the previous
                     ;; uncommented line.
                     ( and  ( save-excursion
                            ( goto-char  indent-point )
                            ( skip-chars-forward  " \t" )
                            ( looking-at  ":" ))
                          ;; The last sexp may not be at the indentation
                          ;; where it begins, so find that one, instead.
                          ( save-excursion
                            ( goto-char  calculate-lisp-indent-last-sexp )
                            ;; Handle prefix characters and whitespace
                            ;; following an open paren.  (Bug#1012)
                            ( backward-prefix-chars )
                            ( while  ( not  ( or  ( looking-back  "^[ \t]*\\|([ \t]+"
                                                          ( line-beginning-position ))
                                            ( and  containing-sexp
                                                 ( >=  ( 1+  containing-sexp )  ( point )))))
                              ( forward-sexp  -1 )
                              ( backward-prefix-chars ))
                            ( setq  calculate-lisp-indent-last-sexp  ( point )))
                          ( >  calculate-lisp-indent-last-sexp
                             ( save-excursion
                               ( goto-char  ( 1+  containing-sexp ))
                               ( parse-partial-sexp  ( point )  calculate-lisp-indent-last-sexp  0  t )
                               ( point )))
                          ( let  (( parse-sexp-ignore-comments  t )
                                indent )
                            ( goto-char  calculate-lisp-indent-last-sexp )
                            ( or  ( and  ( looking-at  ":" )
                                     ( setq  indent  ( current-column )))
                                ( and  ( <  ( line-beginning-position )
                                        ( prog2  ( backward-sexp )  ( point )))
                                     ( looking-at  ":" )
                                     ( setq  indent  ( current-column ))))
                            indent ))
                     ;; another symbols or constants not preceded by a constant
                     ;; as defined above.
                     normal-indent ))
                   ;; in this case calculate-lisp-indent-last-sexp is nil
                   ( desired-indent )
                   ( t
                    normal-indent ))))))
     ( advice-add  #' calculate-lisp-indent  :override  #' rab/calculate-lisp-indent ))
#+end_src

Code Snippet 2: [[https://emacs.stackexchange.com/a/52789][Original]] by Aquaactress on Emacs Stack Exchange, =CC-BY-SA-4.0=.

******** Compilation [[#compilation][#]]

I get a bunch of asynchronous warnings from native compilation in a =*Warnings*= popup. It's nice that they're there, but unless they're an error, I don't need them all up in my business.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  comp
     :custom
     ( native-comp-async-report-warnings-errors  'silent ))
#+end_src

******* Nix [[#nix][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  nix-mode
     :ensure  t
     :defer  t )
#+end_src

******* Scala [[#scala][#]]

Much of this configuration starts from the [[https://scalameta.org/metals/docs/editors/emacs/][Metals guide]].

This doesn't work well with Scala 3's Significant Whitespace Traveshamockery. Once we're ready for that, we'll take a look at [[https://github.com/KaranAhlawat/scala-ts-mode/issues/1#issuecomment-1573884094][scala-ts-mode]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  scala-mode
     :ensure  t
     :interpreter  ( "scala"  .  scala-mode )
     :hook
     ( scala-mode  .  eglot-ensure )
     ( scala-mode  .  subword-mode ))

   ( use-package  sbt-mode
     :ensure  t
     :commands  sbt-start  sbt-command )
#+end_src

******* XML [[#xml][#]]

[[https://github.com/tali713/esxml][esxml]] essentially turns Lisp into an XML (or XHTML) templating engine.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  esxml
     :ensure  t
     :defer  t )
#+end_src

******* YAML [[#yaml][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  yaml-mode
     :ensure  t
     :defer  t )
#+end_src

****** Tools [[#tools][#]]

******* Dumb jump [[#dumb-jump][#]]

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is dumber than LSP, but it's a lot less fussy and makes for a wonderful fallback option.

=git-grep= is not working for me. It appears to be [[https://github.com/jacktasia/dumb-jump/issues/428][option rot]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  dumb-jump
     :ensure  t
     :config
     ( add-hook  'xref-backend-functions  #' dumb-jump-xref-activate )
     :custom
     ( dumb-jump-force-searcher  'rg ))
#+end_src

Make sure ripgrep is available.

MIT

#+begin_src chroma :tabindex 0
    ({  pkgs ,  ... }:  {  home . packages  =  [  pkgs . ripgrep  ];  })
#+end_src

******* Git [[#git][#]]

******** Git Modes [[#git-modes][#]]

[[https://github.com/magit/git-modes][Git modes]] provides three modes:

- =.gitattributes= and similar
- =.gitconfig= and similar
- =.gitignore= and similar

We want them all.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  git-modes
     :defer  t
     :ensure  t )
#+end_src

******** Magit [[#magit][#]]

I have known people to leave Emacs, but continuing to use [[https://magit.vc/][Magit]] for version control. It's that good.

I am giving built-ins the benefit of the doubt in this config, and would like to get into =vc-mode=. But I'm an advanced enough Git user that something tailor-made carries its weight here.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  magit
     :ensure  t
     :defer  1
     :functions  rab/magit-clone-read-args-a
     :bind
     ( :prefix-map  rab/git-map
      :prefix  "C-c g"
      ( "g"  .  magit-status )
      ( "c"  .  magit-clone ))
     :custom
     ( magit-clone-default-directory  "~/src/" )
     ( magit-no-message  ( list  "Turning on magit-auto-revert-mode..." ))
     ( magit-save-repository-buffers  'dontask )
     :config
     ( defun  rab/magit-clone-read-args-a  ( orig-fun  &rest  args )
       "Sets  `vertico-preselect'  to  `prompt'  when cloning repos, so we
   clone to the default prompted directory, and not some random
   existing directory under  `magit-clone-default-directory' ."
       ( let  (( vertico-preselect  'prompt ))
         ( apply  orig-fun  args )))
     ( advice-add  'magit-clone-read-args  :around  #' rab/magit-clone-read-args-a ))
#+end_src

******** Git-Link [[#git-link][#]]

[[https://github.com/sshaw/git-link/][git-link]] grabs links to lines, regions, commits, or home pages.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  git-link
     :ensure  t
     :custom
     ( git-link-use-commit  t )
     ( git-link-use-single-line-number  t )
     :commands  ( git-link  git-link-commit  git-link-homepage ))
#+end_src

******** Git-Related [[#git-related][#]]

[[https://macroexpand.net/pages/git-related.html][=git-related=]] sorts files in a project by a similarity score derived from how often they change in the same commit.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  git-related
     :bind
     ( :map  rab/files-map
      ( "g"  .  git-related-find-file )))
#+end_src

The original is not in a public Git repository, so I [[https://codeberg.org/rossabaker/git-related][forked it]].

I don't prefer the way it propertizes the string with the score. The main thing I want is the sort, so I lightly customized it. The score might still be compelling as an =:annotation-function=.

MIT

#+begin_src chroma :tabindex 0
    epkgs . trivialBuild  {
     pname  =  "git-related" ;
     src  =  inputs . git-related ;
   }
#+end_src

The sort order is customized in [[#vertico-multiform][Vertico multiform]].

******* Restclient [[#restclient][#]]

[[https://github.com/pashky/restclient.el][restclient.el]] is essentially an HTTP worksheet.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  restclient
     :ensure  t
     :defer  t )
#+end_src

I'd like to look into [[https://github.com/alf/ob-restclient.el][ob-restclient.el]] for org-babel integration.

******* Treesitter [[#treesitter][#]]

[[https://github.com/renzmann/treesit-auto][=treesit-auto=]] finds treesitter modes by naming convention.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  treesit-auto
     :ensure  t
     :demand  t
     :config
     ( global-treesit-auto-mode ))
#+end_src

******* UUID Generation [[#uuid-generation][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  uuidgen
     :ensure  t
     :defer  t )
#+end_src

******* Xref [[#xref][#]]

Regardless of LSP or dumb-jump, we want Vertico to handle when multiple definitions are found.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  xref
     :defer
     :custom
     ( xref-show-definitions-function  #' xref-show-definitions-completing-read ))
#+end_src

******* Verb [[#verb][#]]

[[https://github.com/federicotdn/verb][Verb]] is an alternative to [[#restclient][restclient.el]] that many of my colleagues use. The feature sets look roughly equivalent, so I'll give it a shot in the spirit of comity.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  verb
     :after  org
     :ensure  t
     :config  ( define-key  org-mode-map  ( kbd  "C-c C-r" )  verb-command-map ))
#+end_src

***** Applications [[#applications][#]]

****** Dictionary [[#dictionary][#]]

The =M-#= keybinding is dubious because it's not reserved, but it's [[https://www.masteringemacs.org/article/wordsmithing-in-emacs][good enough for Mickey Petersen]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  dictionary
     :bind
     ( "M-#"  .  dictionary-lookup-definition ))
#+end_src

Until I find a working dictd for MacOS on Nix, we'll sigh heavily and use dict.org.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  dictionary
     :if  ( memq  window-system  ' ( mac  ns  x ))
     :custom
     ( dictionary-server  "dict.org" ))
#+end_src

****** Language server protocol [[#language-server-protocol][#]]

We're going to give [[https://joaotavora.github.io/eglot/][eglot]] a try now that it's built into Emacs. It's a bit more minimalist than the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]].

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  eglot  :defer  t )
#+end_src

***** Development [[#development][#]]

****** Extensions [[#extensions][#]]

******* htmlize [[#htmlize][#]]

[[https://github.com/hniksic/emacs-htmlize/blob/master/htmlize.el][=htmlize=]] provides syntax highlighting for our code snippets when exported to HTML.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  htmlize
     :ensure  t
     :after  ox-html )
#+end_src

***** Environment [[#environment][#]]

****** Dired [[#dired][#]]

Dired should refresh the listing on each revisit.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  dired
     :defer
     :custom
     ( dired-auto-revert-buffer  t ))
#+end_src

****** Frames [[#frames][#]]

I like tiled windows more than I need Emacs to maintain a static number of columns and rows.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  frame-inhibit-implied-resize  t )
#+end_src

******* Cursor [[#cursor][#]]

I like a non-blinking bar cursor.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  cursor-type  'bar )
   ( use-package  frame
     :config
     ( blink-cursor-mode  -1 ))
#+end_src

******* Mode line [[#mode-line][#]]

******** Column number [[#column-number][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  simple
     :hook
     ( on-first-buffer  .  column-number-mode ))
#+end_src

******** Size indication [[#size-indication][#]]

Put the buffer size in the mode line. coreutils use binary (base 1024) units, so I will too. I mostly wanted to see if I could. Of course I could. This is Emacs.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( defun  rab/mode-line-binary-size-indication  ()
     "Replaces the size indication in the mode line with base 1024 units."
     ( require  'cl-seq )
     ( setopt  mode-line-position
           ( cl-subst-if
            ' ( size-indication-mode
              ( 8  " of "  ( :eval  ( file-size-human-readable  ( buffer-size )  'iec  ""  "B" ))))
            ( lambda  ( x )  ( and  ( listp  x )  ( eq  'size-indication-mode  ( car  x ))))
            mode-line-position )))
   ( add-hook  'on-first-buffer-hook  #' rab/mode-line-binary-size-indication )
   ( add-hook  'on-first-buffer-hook  #' size-indication-mode )
#+end_src

******* Scroll bars [[#scroll-bars][#]]

The mode line tells us where we're at, and we mostly eschew the mouse.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  scroll-bar
     :config
     ( scroll-bar-mode  -1 ))
#+end_src

******* Tool bars [[#tool-bars][#]]

The much despised tool bar is not a terrible default for the Emacs neophyte, but I'm old and grizzled.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  tool-bar
     :config
     ( tool-bar-mode  -1 ))
#+end_src

******* Minimization: let's not {#minimization-let's-not} [[#minimization-lets-not-minimization-lets-not][#]]

I don't much care for minimizing windows in the first place, and particularly not my favorite window with a keybinding that's too easy to hit.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  frame
     :bind
     ( "C-z"  .  nil ))
#+end_src

******* Beep beep, your ass [[#beep-beep-your-ass][#]]

Decades ago, there was a meme of Wile E. Coyote, having finally caught Road Runner, saying “Beep beep your ass.” This comes from approximately the same era as the last time anyone wanted a system bell.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  mode-line-bell
     :ensure
     :hook  ( on-first-input  .  mode-line-bell-mode ))
#+end_src

****** Faces [[#faces][#]]

******* Fontaine [[#fontaine][#]]

I give an increasing number of live presentations at work. The [[https://protesilaos.com/emacs/fontaine][Fontaine]] package lets me scale up the font for screen sharing, and return to normalcy.

[[https://www.ibm.com/plex/][IBM Plex Mono]] is used if it's installed. Their [[https://www.ibm.com/design/language/typography/type-specs-ui/][=code-02= utility claas]] suggests a line height of 20px, which translates to a =line-spacing= of 6. This is too much. Particularly, the cursor gets distractingly tall when the point is not at a character. [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2015-11/msg00236.html][Bug#21835]] is related. =0.25= gives the text room to breathe, without the cursor growing and shrinking by leaps and bounds.

Note that Emacs line heights are “printer's points,” which are ten to the rest of the world's points.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  fontaine
     :ensure  t
     :demand  t
     :bind
     ( :map  rab/toggles-map
      ( "p"  .  rab/presentation-mode ))
     :custom
     ( fontaine-presets
      ` (( regular
         :default-height  140
         :line-spacing  0.25 )
        ( presentation
         :default-height  210
         :line-spacing  0.125 )
        ( t  ;; defaults
         :default-family
         , ( cond
           (( find-font  ( font-spec  :name  "IBM Plex Mono" ))
            "IBM Plex Mono" )
           ( "Monospace" )))))
     :config
     ( fontaine-set-preset  ( or  fontaine-current-preset  'regular ))
     ( define-minor-mode  rab/presentation-mode
       "Toggles global rab/presentation-mode."
       nil
       :global  t
       ( if  rab/presentation-mode
           ( fontaine-set-preset  'presentation )
         ( fontaine-set-preset  'regular ))))
#+end_src

******* Modus themes [[#modus-themes][#]]

I like the [[https://protesilaos.com/emacs/modus-themes][modus-themes]]. They are built into modern Emacs, but the author continues to work on them, so we grab them from ELPA with =:ensure t=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  modus-themes
     :ensure  t
     :config
     ( load-theme  'modus-operandi  :no-confirm ))
#+end_src

****** Initialization [[#initialization][#]]

I don't need a dashboard and I know where the manuals are. I prefer a quiet startup.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  "startup"
     :custom
     ( inhibit-splash-screen  t )
     ( initial-major-mode  'fundamental-mode )
     ( initial-scratch-message  nil ))
#+end_src

****** Marginalia [[#marginalia][#]]

[[https://github.com/minad/marginalia][Marginalia]] annotates minibuffer completions with some useful info.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  marginalia
     :ensure  t
     :after  vertico
     :bind
     ( :map  minibuffer-local-map
      ( "M-A"  .  marginalia-cycle ))
     :config
     ( marginalia-mode ))
#+end_src

****** Minibuffer [[#minibuffer][#]]

******* Consult [[#consult][#]]

[[https://github.com/minad/consult][Consult]] provides several enhanced functions for =completing-read=. It fits nicely with [[#vertico][Vertico]].

I generally remapped everything obvious. =consult-yank-from-kill-ring= as a remapping of =yank= proved a bit too disorienting.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  consult
     :ensure  t
     :bind
     ([ remap  switch-to-buffer ]  .  consult-buffer )
     ([ remap  switch-to-buffer-other-window ]  .  consult-buffer-other-window )
     ([ remap  switch-to-buffer-other-frame ]  .  consult-buffer-other-frame )
     ([ remap  project-switch-to-buffer ]  .  consult-project-buffer )
     ([ remap  bookmark-jump ]  .  consult-bookmark )
     ([ remap  recentf-open ]  .  consult-recent-file )
     ([ remap  yank ]  .  nil )
     ([ remap  yank-pop ]  .  consult-yank-pop )
     ([ remap  goto-line ]  .  consult-goto-line )
     ( "M-g m"  .  consult-mark )
     ( "M-g M"  .  consult-global-mark )
     ( "M-g o"  .  consult-outline )
     ( "M-g i"  .  consult-imenu )
     ( "M-g I"  .  consult-imenu-multi )
     ( "M-s l"  .  consult-line )
     ( "M-s L"  .  consult-line-multi )
     ( "M-s k"  .  consult-keep-lines )
     ( "M-s u"  .  consult-focus-lines )
     ( "M-s r"  .  consult-ripgrep )
     ( "M-s f"  .  consult-find )
     ( "M-s F"  .  consult-locate )
     ( "M-g e"  .  consult-compile-error )
     ( "M-g f"  .  consult-flymake )
     ([ remap  repeat-complex-command ]  .  consult-complex-command )
     ( "M-s e"  .  consult-isearch-history )
     ([ remap  isearch-edit-string ]  .  consult-isearch-history )
     ([ remap  next-matching-history-element ]  .  consult-history )
     ([ remap  previous-matching-history-element ]  .  consult-history )
     ([ remap  Info-search ]  .  consult-info )
     :custom
     ( xref-show-xrefs-function  'consult-xref )
     ( xref-show-definitions-function  'consult-xref ))
#+end_src

****** Menu [[#menu][#]]

Dialog boxes are an unemacsian abomination.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( setopt  use-dialog-box  nil )
#+end_src

****** Mouse [[#mouse][#]]

I don't use the mouse much in Emacs, but if I do, it's the scroll wheel. This makes it feel less like a trip back to a time before scroll wheels.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  pixel-scroll
     :hook
     ( on-first-buffer  .  pixel-scroll-precision-mode ))
#+end_src

****** Vertico [[#vertico][#]]

[[https://github.com/minad/vertico][Vertico]] is a little bit nicer version of the builtin =icomplete-vertical=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  vertico
     :ensure  t
     :hook  ( on-first-input  .  vertico-mode ))
#+end_src

******* Vertico indexed [[#vertico-indexed][#]]

=vertico-indexed= lets us select candidates by number with =C-u RET=. It's an alternative to =vertico-quick=.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  vertico-indexed
     :after  vertico
     :config  ( vertico-indexed-mode ))
#+end_src

******* Vertico repeat [[#vertico-repeat][#]]

=vertico-repeat= resumes a prior completion session.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  vertico-repeat
     :after  vertico
     :hook  ( minibuffer-setup  .  vertico-repeat-save )
     :bind  ( "M-R"  .  vertico-repeat ))
#+end_src

******* Vertico directory [[#vertico-directory][#]]

=vertico-directory= does some smarter things when completing directories:

- =RET= continues completing in that directory instead of jumping to dired.
- =M-DEL= deletes whole directories at a time if the prompt ends in a slash. There's a recommended binding for =DEL=, but I'd rather keep that deleting chars.

I never understood =vertico-directory-tidy= before [[https://kristofferbalintona.me/posts/202202211546/#niceties][this demo]]. When we start with =/= or =~/=, it cleans up the leading default prompt that's “shadowed”.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  vertico-directory
     :after  vertico
     :bind
     ( :map  vertico-map
      ( "RET"  .  vertico-directory-enter )
      ( "M-DEL"  .  vertico-directory-delete-word ))
     :hook  ( rfn-eshadow-update-overlay  .  vertico-directory-tidy ))
#+end_src

******* Vertico multiform [[#vertico-multiform][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  vertico-multiform
     :after  vertico
     :custom
     ( vertico-multiform-commands  ' (( git-related-find-file  ( vertico-sort-function  .  nil ))))
     :config
     ( vertico-multiform-mode ))
#+end_src

******* Zoom [[#zoom][#]]

[[https://github.com/cyrus-and/zoom][Zoom]] resizes the selected window. It's a modernized version of [[https://github.com/roman/golden-ratio.el][golden-ratio.el]], and indeed, we configure it to use the golden ratio.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  zoom
     :ensure  t
     :custom
     ` ( zoom-size  , ( let  (( phi  ( -  ( /  ( +  1  ( sqrt  5 ))  2 )  1 )))
                   ( cons  phi  phi ))))
#+end_src

***** Help [[#help][#]]

****** Which Key [[#which-key][#]]

[[https://github.com/justbur/emacs-which-key][=which-key=]] pops up a menu of keybindings. The traditional way is to run it on a timer, but I prefer [[https://github.com/justbur/emacs-which-key#manual-activation][manual activation]].

I also relabel all my keymaps of the form =rab/blah-map= to =blah=. Neither =:prefix-docstring= nor =:menu-item= in =bind-key= seem to do the trick.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  which-key
     :ensure  t
     :hook  ( on-first-input  .  which-key-mode )
     :diminish
     :custom
     ( which-key-show-early-on-C-h  t )
     ( which-key-idle-delay  most-positive-fixnum )
     ( which-key-idle-secondary-delay  1e-9 )
     :config
     ( push  ` (( nil  .  , ( rx  bos  "rab/"  ( group  ( 1+  any ))  "-map"  eos ))  .
             ( nil  .  , ( rx  ( backref  1 ))))
           which-key-replacement-alist ))
#+end_src

=C-h C-h= shadows which-key with something less useful.

CC0-1.0

#+begin_src chroma :tabindex 0
    ( use-package  help
     :config
     ( rab/unbind-all  'help-for-help ))
#+end_src

***** Junk drawer [[#junk-drawer][#]]

These customizations don't fit anywhere else.

****** Remove the training wheels [[#remove-the-training-wheels][#]]

CC0-1.0

#+begin_src chroma :tabindex 0
    ( put  'narrow-to-region  'disabled  nil )
#+end_src

**** Nix module [[#nix-module][#]]

This Emacs configuration is built with Nix using [[https://github.com/nix-community/emacs-overlay][emacs-overlay]] and published to my [[/configs/nix-flake/#whats-in-the-flake][Nix flake]].

Even though Emacs 29 is not released at the time of writing, git is on Emacs 30! We publish an =emacs29= flake package with the desired branch pinned via the =emacs-src= input. It's also added to our default overlay, so it can be used as a dependency by other packages and apps. The package has no configuration.

Additionally, an =emacs= flake app is created. This builds on the =emacs29= package with the config above to make a usable Emacs.

Finally, we add a Home Manager module based on the configured app.

MIT

#+begin_src chroma :tabindex 0
    {  inputs ,  lib ,  moduleWithSystem ,  ...  }:  {
     imports  =  [
       inputs . flake-parts . flakeModules . easyOverlay
     ];
     perSystem  =  {  config ,  self' ,  inputs' ,  pkgs ,  system ,  ...  }:  {
       overlayAttrs  =  {
         inherit  ( config . packages )  emacs29 ;
       };
       packages . emacs29  =  pkgs . emacs-git . overrideAttrs  ( old :  {
         name  =  "emacs29" ;
         # It's important this starts with the major number for Nix's
         # Emacs infra.  For example, it's used to blank out archaic
         # versions of the Seq package in MELPA.
         version  =  "29.0- ${ inputs . emacs-src . shortRev } " ;
         src  =  inputs . emacs-src ;
         # This doesn't apply to Emacs29.
         patches  =  builtins . filter  ( p :  baseNameOf  p  !=  "bytecomp-revert.patch" )  old . patches ;
       });
       packages . emacs-ross  =  pkgs . emacsWithPackagesFromUsePackage  {
         package  =  config . packages . emacs29 ;
         override  =  epkgs :  epkgs  //  {
         on  =  epkgs . trivialBuild  {
           pname  =  "on.el" ;
           src  =  inputs . on-el ;
         };
         jinx  =
           <  > ;
         copilot  =
           <  > ;
         ox-slack  =
           <  > ;
         git-related  =
           <  > ;
         };
         config  =  ./init.el ;
         defaultInitFile  =  true ;
         alwaysEnsure  =  false ;
       };
       apps . emacs  =  {
         type  =  "app" ;
         program  =  " ${ config . packages . emacs-ross } /bin/emacs" ;
       };
     };
     flake  =  {
       homeManagerModules . emacs  =  moduleWithSystem  (
         perSystem @ {  config ,  pkgs  }:  {
         imports  =  [
           <  >
           ./load-path.nix
         ];
         programs . emacs  =  {
           enable  =  true ;
           package  =  config . packages . emacs-ross ;
         };
         }
       );
     };
   }
#+end_src

As long as I have access to Nix, I can install and run my complete Emacs app as a one-liner. There's little reason for you to choose it over a starter kit or your own configuration, but there's also nothing stopping you!

CC-BY-SA-4.0

#+begin_src chroma :tabindex 0
   nix run github:rossabaker/cromulent#emacs
#+end_src

***** On-the-fly load-paths [[#on-the-fly-load-paths][#]]

A disadvantage to a Nix-based Emacs config is that we have to restart Emacs every time we install a new package. [[https://discourse.nixos.org/t/emacs-exwm-home-manager-and-loading-new-emacs-modules/10097/3][This hack]] from the Nix forums lets us update the =load-path= after a home-manager switch. From the original posting, we change =finalPackage= to =package=: =finalPackage= refers to a wrapper with an empty site-lisp.

The solution is [[https://discourse.nixos.org/tos#3][licensed CC-BY-NC-SA-3.0]], which is incompatible.

Finally, a convenience function to reload it. This won't work until we find a licensed solution for =load-path.el=.

#+begin_src chroma :tabindex 0
   (defun rab/refresh-load-path ()
    "Refresh the load path written by home-manager to pick up new
   packages without restarting Emacs."
    (interactive)
    (load-file "~/.config/emacs/load-path.el"))
#+end_src

- Type :: [[/configs][Config]]
- Published :: 2023-02-23
- Last updated :: 2023-08-31
- Taxonomies :: - Categories :: - [[https://rossabaker.com/categories/tech][Tech]]

  - Tags :: - [[https://rossabaker.com/tags/emacs][emacs]]
